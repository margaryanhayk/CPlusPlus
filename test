#include <iostream>
#include <thread>
#include <vector>

class A
{
public:
	struct SomeFunction
	{
		int k = 4;
		void operator()(std::vector<int>::iterator start, std::vector<int>::iterator end)
		{
			for (auto it = start; it < end; ++it)
			{

				*it *= k;
			}
		}
	};
	template<typename T>
	std::vector<T> f(const std::vector<T>& vec)
	{
		std::vector<T> new_vec = vec;
		const int step = new_vec.size() / num_threads;
		const int rest = new_vec.size() % num_threads;
		for (int ix = 0; ix < num_threads; ++ix)
		{
			SomeFunction* functor = new SomeFunction();
			processors_.push_back(std::thread(std::ref(*functor), new_vec.begin() + (ix * step), new_vec.begin() + ((ix + 1) * step)));
		}
		if (rest)
		{
			SomeFunction* functor = new SomeFunction();
			processors_.push_back(std::thread(std::ref(*functor), new_vec.end() - rest, new_vec.end()));
		}
		for (auto& t : processors_)
		{
			if (t.joinable()) { t.join(); }
		}
		return new_vec;
	}
public:
	static constexpr int num_threads = 8;
private:
	std::vector<std::thread> processors_;
};
